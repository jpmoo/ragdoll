<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RAGDoll Review – Source &amp; Samples</title>
  <style>
    :root {
      --bg: #0f0f12;
      --surface: #18181c;
      --border: #2a2a30;
      --text: #e4e4e7;
      --muted: #71717a;
      --accent: #a78bfa;
      --accent-hover: #c4b5fd;
      --danger: #f87171;
      --danger-hover: #fca5a5;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "DM Sans", system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.5;
    }
    .layout {
      display: grid;
      grid-template-columns: 3fr 2fr; /* 60% document, 40% samples */
      grid-template-rows: auto 1fr;
      height: 100vh;
      gap: 0;
    }
    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; grid-template-rows: auto auto 1fr; }
    }
    header {
      grid-column: 1 / -1;
      padding: 0.75rem 1rem;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    header h1 { margin: 0; font-size: 1.1rem; font-weight: 600; }
    header select, header input, header button {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      font-size: 0.9rem;
    }
    header select { min-width: 120px; }
    header input[type="number"] { width: 4rem; }
    header button {
      cursor: pointer;
      background: var(--accent);
      color: var(--bg);
      border: none;
    }
    header button:hover { background: var(--accent-hover); }
    .panel {
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--border);
      min-height: 0;
    }
    .panel:last-of-type { border-right: none; }
    .panel-title {
      padding: 0.5rem 1rem;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--muted);
    }
    .source-view {
      flex: 1;
      min-height: 200px;
      background: var(--bg);
    }
    .source-view iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
    .source-view .placeholder {
      padding: 2rem;
      text-align: center;
      color: var(--muted);
    }
    .pdf-viewer {
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 0;
    }
    .pdf-toolbar {
      flex-shrink: 0;
      padding: 0.4rem 0.75rem;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .pdf-toolbar button {
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      font-size: 0.85rem;
    }
    .pdf-toolbar button:hover { background: var(--border); }
    .pdf-toolbar .page-info { font-size: 0.85rem; color: var(--muted); }
    .pdf-canvas-wrap {
      flex: 1;
      overflow: auto;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 0.5rem;
    }
    .pdf-page {
      position: relative;
      display: inline-block;
    }
    .pdf-page canvas { display: block; max-width: 100%; height: auto; position: relative; z-index: 0; }
    .pdf-text-layer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      line-height: 1;
      z-index: 1;
      pointer-events: none;
      user-select: text;
    }
    .pdf-text-layer span {
      color: transparent;
      position: absolute;
      white-space: pre;
      cursor: text;
      pointer-events: auto;
      transform-origin: 0% 0%;
      display: inline-block;
    }
    .pdf-no-text-msg {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 0.5rem;
      background: rgba(0,0,0,0.7);
      color: var(--muted);
      font-size: 0.8rem;
      z-index: 2;
    }
    .pdf-no-text-msg a { color: var(--accent); }
    .samples-toolbar {
      padding: 0.5rem 1rem;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .samples-toolbar label { display: flex; align-items: center; gap: 0.4rem; font-size: 0.85rem; color: var(--muted); }
    .samples-toolbar input[type="number"] { width: 4rem; padding: 0.3rem 0.5rem; border-radius: 4px; border: 1px solid var(--border); background: var(--bg); color: var(--text); }
    .samples-toolbar .toolbar-add {
      margin-left: auto;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      font-size: 0.85rem;
      cursor: pointer;
    }
    .samples-toolbar .toolbar-add:hover { background: var(--accent); color: var(--bg); border-color: var(--accent); }
    .samples-list {
      flex: 1;
      overflow: auto;
      padding: 0.5rem;
    }
    .sample-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      margin-bottom: 0.5rem;
      position: relative;
    }
    .sample-card .meta { font-size: 0.75rem; color: var(--muted); margin-bottom: 0.4rem; }
    .sample-card .semantic-block { margin-top: 0.5rem; font-size: 0.8rem; }
    .sample-card .semantic-row { margin-bottom: 0.25rem; }
    .sample-card .semantic-label { color: var(--muted); margin-right: 0.35rem; }
    .sample-card .semantic-value { color: var(--text); }
    .sample-card .text { white-space: pre-wrap; word-break: break-word; }
    .sample-card .text.editing { font-style: italic; }
    .sample-card input[type="text"], .sample-card select {
      width: 100%;
      max-width: 100%;
      padding: 0.25rem 0.4rem;
      margin-top: 0.15rem;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .sample-card textarea {
      width: 100%;
      min-height: 80px;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.5rem;
      border-radius: 4px;
      font: inherit;
      resize: vertical;
    }
    .sample-actions {
      margin-top: 0.5rem;
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }
    .sample-actions button {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
    }
    .sample-actions button:hover { background: var(--border); }
    .sample-actions button.danger { border-color: var(--danger); color: var(--danger); }
    .sample-actions button.danger:hover { background: var(--danger); color: var(--bg); }
    .sample-actions button.primary { background: var(--accent); color: var(--bg); border: none; }
    .sample-actions button.primary:hover { background: var(--accent-hover); }
    .empty-state { padding: 2rem; text-align: center; color: var(--muted); }
    .modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 200;
      align-items: center;
      justify-content: center;
    }
    .modal-overlay.visible { display: flex; }
    .modal-box {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      max-width: 520px;
      width: 90%;
      max-height: 90vh;
      overflow: auto;
    }
    .modal-box h3 { margin: 0 0 0.75rem 0; font-size: 1rem; }
    .modal-box .form-row { margin-bottom: 0.5rem; }
    .modal-box label { display: block; font-size: 0.8rem; color: var(--muted); margin-bottom: 0.2rem; }
    .modal-box input, .modal-box select, .modal-box textarea {
      width: 100%;
      padding: 0.35rem 0.5rem;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 4px;
      font: inherit;
    }
    .modal-box textarea { min-height: 60px; resize: vertical; }
    .modal-actions { margin-top: 1rem; display: flex; gap: 0.5rem; justify-content: flex-end; }
    .toast {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      padding: 0.5rem 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 0.9rem;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div class="layout">
    <header>
      <h1>RAGDoll Review</h1>
      <select id="groupSelect" aria-label="Group">
        <option value="">Select group…</option>
      </select>
      <select id="sourceSelect" aria-label="Source" disabled>
        <option value="">Select source…</option>
      </select>
      <a id="openSource" href="#" target="_blank" rel="noopener" style="color: var(--accent); font-size: 0.9rem;">Open in new tab</a>
    </header>

    <section class="panel">
      <div class="panel-title">Source</div>
      <div class="source-view">
        <div class="placeholder" id="sourcePlaceholder">Select a group and source to view the document.</div>
        <iframe id="sourceFrame" title="Source document" style="display: none;"></iframe>
        <div class="pdf-viewer" id="pdfViewer" style="display: none;">
          <div class="pdf-toolbar">
            <button type="button" id="pdfPrev" aria-label="Previous page">Prev</button>
            <span class="page-info" id="pdfPageInfo">Page 1 of 1</span>
            <button type="button" id="pdfNext" aria-label="Next page">Next</button>
          </div>
          <div class="pdf-canvas-wrap">
            <div class="pdf-page" id="pdfPage">
              <canvas id="pdfCanvas"></canvas>
              <div class="pdf-text-layer" id="pdfTextLayer" aria-hidden="true"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel">
      <div class="panel-title">Samples (chunks)</div>
      <div class="samples-toolbar">
        <label><input type="radio" name="filter" value="all" checked> All samples</label>
        <label><input type="radio" name="filter" value="page"> Page <input type="number" id="pageNum" min="1" value="1" aria-label="Page number"></label>
        <button type="button" id="addAtTop" class="toolbar-add">Add at top</button>
        <button type="button" id="addAtBottom" class="toolbar-add">Add at bottom</button>
      </div>
      <div class="samples-list" id="samplesList">
        <div class="empty-state">Select a source to list samples.</div>
      </div>
    </section>
  </div>

  <div id="toast" class="toast" style="display: none;" role="status"></div>

  <div id="addSampleModal" class="modal-overlay" role="dialog" aria-label="Add sample">
    <div class="modal-box">
      <h3 id="addSampleTitle">Add sample</h3>
      <form id="addSampleForm">
        <div class="form-row">
          <label for="addText">Chunk text *</label>
          <textarea id="addText" required></textarea>
        </div>
        <div class="form-row">
          <label for="addConcept">Concept</label>
          <input type="text" id="addConcept" />
        </div>
        <div class="form-row">
          <label for="addDecisionContext">Decision context</label>
          <input type="text" id="addDecisionContext" />
        </div>
        <div class="form-row">
          <label for="addPrimaryQuestion">Primary question answered</label>
          <input type="text" id="addPrimaryQuestion" />
        </div>
        <div class="form-row">
          <label for="addKeySignals">Key signals (one per line)</label>
          <textarea id="addKeySignals" rows="3"></textarea>
        </div>
        <div class="form-row">
          <label for="addChunkRole">Chunk role</label>
          <select id="addChunkRole">
            <option value="">—</option>
            <option value="definition">definition</option>
            <option value="framework explanation">framework explanation</option>
            <option value="diagnostic guidance">diagnostic guidance</option>
            <option value="action/strategy">action/strategy</option>
            <option value="example/application">example/application</option>
            <option value="implications/consequences">implications/consequences</option>
          </select>
        </div>
        <div class="modal-actions">
          <button type="button" id="addSampleCancel">Cancel</button>
          <button type="submit" class="primary">Add</button>
        </div>
      </form>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    if (typeof pdfjsLib !== 'undefined') {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
  </script>
  <script>
    const API = '/api';
    let state = { group: '', sourceId: null, source: null, chunks: [], pdfDoc: null, currentPdfPage: 1, pdfNumPages: 1 };

    function qs(sel, el = document) { return el.querySelector(sel); }
    function qsAll(sel, el = document) { return el.querySelectorAll(sel); }

    function toast(msg) {
      const el = qs('#toast');
      el.textContent = msg;
      el.style.display = 'block';
      clearTimeout(el._t);
      el._t = setTimeout(() => { el.style.display = 'none'; }, 3000);
    }

    async function fetchJson(path) {
      const r = await fetch(API + path);
      if (!r.ok) throw new Error(r.statusText || r.status);
      return r.json();
    }

    async function loadGroups() {
      const { groups } = await fetchJson('/groups');
      const sel = qs('#groupSelect');
      sel.innerHTML = '<option value="">Select group…</option>' + groups.map(g => `<option value="${g}">${g}</option>`).join('');
    }

    async function loadSources() {
      if (!state.group) return;
      const { sources } = await fetchJson(`/groups/${encodeURIComponent(state.group)}/sources`);
      const sel = qs('#sourceSelect');
      sel.disabled = false;
      sel.innerHTML = '<option value="">Select source…</option>' + sources.map(s =>
        `<option value="${s.source_id}" data-fetch-path="${(s.fetch_path || '').replace(/"/g, '&quot;')}">${s.display_name || s.source_id} (${s.chunk_count})</option>`
      ).join('');
      state.sourceId = null;
      state.source = null;
      renderSource();
      renderChunks();
    }

    function onGroupChange() {
      state.group = qs('#groupSelect').value || '';
      qs('#sourceSelect').disabled = !state.group;
      qs('#sourceSelect').innerHTML = '<option value="">Select source…</option>';
      state.sourceId = null;
      state.source = null;
      if (state.group) loadSources();
      else { renderSource(); renderChunks(); }
    }

    function onSourceChange() {
      const sel = qs('#sourceSelect');
      const opt = sel.selectedOptions[0];
      state.sourceId = opt ? parseInt(opt.value, 10) : null;
      state.source = opt ? { fetch_path: opt.dataset.fetchPath } : null;
      renderSource();
      loadChunks();
    }

    function renderSource() {
      const ph = qs('#sourcePlaceholder');
      const frame = qs('#sourceFrame');
      const pdfViewer = qs('#pdfViewer');
      const link = qs('#openSource');
      if (!state.group || !state.source) {
        ph.style.display = 'block';
        frame.style.display = 'none';
        pdfViewer.style.display = 'none';
        frame.src = '';
        link.href = '#';
        link.style.display = 'none';
        state.pdfDoc = null;
        return;
      }
      const path = state.source.fetch_path;
      if (!path) {
        ph.textContent = 'No preview path for this source.';
        ph.style.display = 'block';
        frame.style.display = 'none';
        pdfViewer.style.display = 'none';
        link.href = '#';
        link.style.display = 'none';
        state.pdfDoc = null;
        return;
      }
      const url = `${API}/groups/${encodeURIComponent(state.group)}/fetch/${path.split('/').map(encodeURIComponent).join('/')}`;
      link.href = url;
      link.style.display = 'inline';
      const ext = (path.split('.').pop() || '').toLowerCase();
      if (ext === 'pdf') {
        pdfViewer.style.display = 'none';
        ph.style.display = 'none';
        frame.src = url;
        frame.style.display = 'block';
        state.pdfDoc = null;
      } else if (['png', 'jpg', 'jpeg', 'gif'].includes(ext)) {
        pdfViewer.style.display = 'none';
        frame.src = url;
        frame.style.display = 'block';
        ph.style.display = 'none';
      } else {
        frame.style.display = 'none';
        pdfViewer.style.display = 'none';
        ph.innerHTML = 'Preview not available. <a href="' + url + '" target="_blank" rel="noopener">Open in new tab</a>';
        ph.style.display = 'block';
      }
    }

    function setPdfPage(n) {
      if (!state.pdfDoc || n < 1 || n > state.pdfNumPages) return;
      state.currentPdfPage = n;
      qs('#pdfPageInfo').textContent = 'Page ' + n + ' of ' + state.pdfNumPages;
      qs('#pageNum').value = n;
      qs('#pageNum').min = 1;
      qs('#pageNum').max = state.pdfNumPages;
      state.pdfDoc.getPage(n).then(function(page) {
        const scale = 1.5;
        const viewport = page.getViewport({ scale: scale });
        const canvas = qs('#pdfCanvas');
        const ctx = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        const pageWrap = qs('#pdfPage');
        const textLayer = qs('#pdfTextLayer');
        pageWrap.style.width = viewport.width + 'px';
        pageWrap.style.height = viewport.height + 'px';
        textLayer.style.width = viewport.width + 'px';
        textLayer.style.height = viewport.height + 'px';
        textLayer.innerHTML = '';
        page.render({ canvasContext: ctx, viewport: viewport }).then(function() {
          return page.getTextContent();
        }).then(function(textContent) {
          textContent.items.forEach(function(item) {
            var tx = item.transform;
            var span = document.createElement('span');
            span.textContent = item.str;
            span.style.left = (tx[4] * scale) + 'px';
            span.style.top = (viewport.height - tx[5] * scale) + 'px';
            span.style.fontSize = ((item.height || 12) * scale) + 'px';
            span.style.fontFamily = (item.fontName && item.fontName.name) ? item.fontName.name : 'sans-serif';
            textLayer.appendChild(span);
          });
        }).catch(function() { /* no text content or render failed */ });
      });
      if (qs('input[name="filter"]:checked').value === 'page') {
        loadChunks();
      }
    }

    async function loadChunks() {
      if (!state.group || state.sourceId == null) {
        state.chunks = [];
        renderChunks();
        return;
      }
      const filter = qs('input[name="filter"]:checked').value;
      const pageNum = filter === 'page' ? parseInt(qs('#pageNum').value, 10) : null;
      const path = `/groups/${encodeURIComponent(state.group)}/sources/${state.sourceId}/chunks` + (pageNum != null && pageNum >= 1 ? `?page=${pageNum}` : '');
      try {
        const { chunks } = await fetchJson(path);
        state.chunks = chunks || [];
      } catch (e) {
        state.chunks = [];
        toast('Failed to load samples: ' + e.message);
      }
      renderChunks();
    }

    function renderChunks() {
      const list = qs('#samplesList');
      if (!state.group || state.sourceId == null) {
        list.innerHTML = '<div class="empty-state">Select a source to list samples.</div>';
        return;
      }
      if (!state.chunks.length) {
        list.innerHTML = '<div class="empty-state">No samples for this source / page.</div>';
        return;
      }
      list.innerHTML = state.chunks.map(c => sampleCard(c)).join('');
      list.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', () => handleAction(btn.dataset.action, btn.dataset.id, btn.dataset.index));
      });
    }

    const CHUNK_ROLES = ['definition', 'framework explanation', 'diagnostic guidance', 'action/strategy', 'example/application', 'implications/consequences'];

    function sampleCard(c) {
      const pageInfo = c.page != null ? `Page ${c.page}` : '—';
      const concept = (c.concept || '').trim();
      const decisionContext = (c.decision_context || '').trim();
      const primaryQuestion = (c.primary_question_answered || '').trim();
      const keySignals = Array.isArray(c.key_signals) ? c.key_signals.join('\n') : (c.key_signals || '');
      const chunkRole = (c.chunk_role || '').trim();
      const keySignalsDisplay = Array.isArray(c.key_signals) ? c.key_signals.join(', ') : (c.key_signals || '');
      const semanticRows = [
        ['Concept', concept],
        ['Decision context', decisionContext],
        ['Primary question answered', primaryQuestion],
        ['Key signals', keySignalsDisplay],
        ['Chunk role', chunkRole],
      ].map(([l, v]) => `<div class="semantic-row"><span class="semantic-label">${escapeHtml(l)}:</span><span class="semantic-value">${escapeHtml(v) || '—'}</span></div>`).join('');
      const roleOptions = CHUNK_ROLES.map(r => `<option value="${escapeHtml(r)}"${r === chunkRole ? ' selected' : ''}>${escapeHtml(r)}</option>`).join('');
      const hasAbove = state.chunks.some(ch => ch.chunk_index === c.chunk_index - 1);
      const hasBelow = state.chunks.some(ch => ch.chunk_index === c.chunk_index + 1);
      return `
        <div class="sample-card" data-id="${c.id}">
          <div class="meta">#${c.chunk_index} · ${pageInfo} · ${c.artifact_type || 'text'}</div>
          <div class="semantic-block semantic-view">${semanticRows}</div>
          <div class="semantic-block semantic-edit" style="display: none;">
            <div class="semantic-row"><span class="semantic-label">Concept</span><input type="text" data-field="concept" value="${escapeHtml(concept)}" /></div>
            <div class="semantic-row"><span class="semantic-label">Decision context</span><input type="text" data-field="decision_context" value="${escapeHtml(decisionContext)}" /></div>
            <div class="semantic-row"><span class="semantic-label">Primary question answered</span><input type="text" data-field="primary_question_answered" value="${escapeHtml(primaryQuestion)}" /></div>
            <div class="semantic-row"><span class="semantic-label">Key signals (one per line)</span><textarea data-field="key_signals" rows="2">${escapeHtml(keySignals)}</textarea></div>
            <div class="semantic-row"><span class="semantic-label">Chunk role</span><select data-field="chunk_role"><option value="">—</option>${roleOptions}</select></div>
          </div>
          <div class="text" data-id="${c.id}">${escapeHtml(c.text)}</div>
          <textarea data-id="${c.id}" class="edit-text" style="display: none;"></textarea>
          <div class="sample-actions">
            <button data-action="edit" data-id="${c.id}">Edit</button>
            <button data-action="joinAbove" data-id="${c.id}" ${hasAbove ? '' : 'disabled'}>Join with above</button>
            <button data-action="joinBelow" data-id="${c.id}" ${hasBelow ? '' : 'disabled'}>Join with below</button>
            <button data-action="insertAbove" data-id="${c.id}" data-index="${c.chunk_index}">Insert above</button>
            <button data-action="insertBelow" data-id="${c.id}" data-index="${c.chunk_index}">Insert below</button>
            <button data-action="delete" data-id="${c.id}" class="danger">Delete</button>
          </div>
        </div>
      `;
    }

    function escapeHtml(s) {
      const div = document.createElement('div');
      div.textContent = s;
      return div.innerHTML;
    }

    async function handleAction(action, id, index) {
      const group = encodeURIComponent(state.group);
      const chunkId = id;
      const chunkIndex = parseInt(index, 10);

      function getSemanticFromCard(card) {
        const editBlock = card.querySelector('.semantic-edit');
        if (!editBlock) return {};
        const concept = (editBlock.querySelector('[data-field="concept"]')?.value || '').trim();
        const decision_context = (editBlock.querySelector('[data-field="decision_context"]')?.value || '').trim();
        const primary_question_answered = (editBlock.querySelector('[data-field="primary_question_answered"]')?.value || '').trim();
        const key_signalsRaw = (editBlock.querySelector('[data-field="key_signals"]')?.value || '').trim();
        const key_signals = key_signalsRaw ? key_signalsRaw.split(/\n/).map(s => s.trim()).filter(Boolean) : [];
        const chunk_role = (editBlock.querySelector('[data-field="chunk_role"]')?.value || '').trim();
        return { concept, decision_context, primary_question_answered, key_signals, chunk_role };
      }

      if (action === 'edit') {
        const card = qs(`.sample-card[data-id="${chunkId}"]`);
        const textEl = card.querySelector('.text');
        const ta = card.querySelector('.edit-text');
        const semanticView = card.querySelector('.semantic-view');
        const semanticEdit = card.querySelector('.semantic-edit');
        if (ta && ta.style.display === 'block') {
          const newText = ta.value.trim();
          const semantic = getSemanticFromCard(card);
          try {
            const r = await fetch(API + `/groups/${group}/chunks/${chunkId}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text: newText, ...semantic }),
            });
            if (!r.ok) throw new Error();
            textEl.textContent = newText;
            ta.style.display = 'none';
            textEl.style.display = 'block';
            if (semanticView) semanticView.style.display = 'block';
            if (semanticEdit) semanticEdit.style.display = 'none';
            card.querySelector('[data-action="saveEdit"]').textContent = 'Edit';
            card.querySelector('[data-action="saveEdit"]').dataset.action = 'edit';
            toast('Saved.');
            loadChunks();
          } catch (e) {
            toast('Failed to save.');
          }
          return;
        }
        ta.value = textEl.textContent;
        textEl.style.display = 'none';
        ta.style.display = 'block';
        if (semanticView) semanticView.style.display = 'none';
        if (semanticEdit) semanticEdit.style.display = 'block';
        ta.focus();
        const saveBtn = card.querySelector('[data-action="edit"]');
        saveBtn.textContent = 'Save';
        saveBtn.dataset.action = 'saveEdit';
        return;
      }

      if (action === 'saveEdit') {
        const card = qs(`.sample-card[data-id="${chunkId}"]`);
        const textEl = card.querySelector('.text');
        const ta = card.querySelector('.edit-text');
        const semanticView = card.querySelector('.semantic-view');
        const semanticEdit = card.querySelector('.semantic-edit');
        const newText = ta.value.trim();
        const semantic = getSemanticFromCard(card);
        try {
          const r = await fetch(API + `/groups/${group}/chunks/${chunkId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: newText, ...semantic }),
          });
          if (!r.ok) throw new Error();
          textEl.textContent = newText;
          ta.style.display = 'none';
          textEl.style.display = 'block';
          if (semanticView) semanticView.style.display = 'block';
          if (semanticEdit) semanticEdit.style.display = 'none';
          card.querySelector('[data-action="saveEdit"]').textContent = 'Edit';
          card.querySelector('[data-action="saveEdit"]').dataset.action = 'edit';
          toast('Saved.');
          loadChunks();
        } catch (e) {
          toast('Failed to save.');
        }
        return;
      }

      if (action === 'insertAbove' || action === 'insertBelow') {
        state.addSampleMode = action === 'insertAbove' ? { type: 'above', index: chunkIndex } : { type: 'below', index: chunkIndex };
        qs('#addSampleTitle').textContent = action === 'insertAbove' ? 'Insert sample above' : 'Insert sample below';
        qs('#addSampleForm').reset();
        qs('#addSampleModal').classList.add('visible');
        return;
      }

      if (action === 'joinAbove' || action === 'joinBelow') {
        const endpoint = action === 'joinAbove' ? 'join-above' : 'join-below';
        if (!confirm(action === 'joinAbove' ? 'Merge the chunk above into this one? Its text will be added before this chunk, then semantic labels and embedding will be re-run.' : 'Merge the chunk below into this one? Its text will be added after this chunk, then semantic labels and embedding will be re-run.')) return;
        try {
          const r = await fetch(API + `/groups/${group}/chunks/${chunkId}/${endpoint}`, { method: 'POST' });
          if (!r.ok) {
            const err = await r.json().catch(() => ({}));
            throw new Error(err.detail || r.statusText);
          }
          toast('Joined.');
          loadChunks();
        } catch (e) {
          toast('Failed: ' + (e.message || 'join'));
        }
        return;
      }

      if (action === 'delete') {
        if (!confirm('Delete this sample?')) return;
        try {
          const r = await fetch(API + `/groups/${group}/chunks/${chunkId}`, { method: 'DELETE' });
          if (!r.ok) throw new Error();
          toast('Deleted.');
          loadChunks();
        } catch (e) {
          toast('Failed to delete.');
        }
      }
    }

    qs('#groupSelect').addEventListener('change', onGroupChange);
    qs('#sourceSelect').addEventListener('change', onSourceChange);
    qsAll('input[name="filter"]').forEach(el => el.addEventListener('change', function() {
      if (this.value === 'page' && state.pdfDoc) {
        qs('#pageNum').value = state.currentPdfPage;
        qs('#pageNum').max = state.pdfNumPages;
      }
      loadChunks();
    }));
    qs('#pageNum').addEventListener('change', function() {
      const n = parseInt(this.value, 10);
      if (state.pdfDoc && n >= 1 && n <= state.pdfNumPages) setPdfPage(n);
      else loadChunks();
    });
    qs('#pdfPrev').addEventListener('click', function() {
      if (state.pdfDoc && state.currentPdfPage > 1) setPdfPage(state.currentPdfPage - 1);
    });
    qs('#pdfNext').addEventListener('click', function() {
      if (state.pdfDoc && state.currentPdfPage < state.pdfNumPages) setPdfPage(state.currentPdfPage + 1);
    });

    function openAddSampleModal(mode) {
      if (!state.group || state.sourceId == null) {
        toast('Select a source first.');
        return;
      }
      state.addSampleMode = mode;
      qs('#addSampleTitle').textContent = mode.type === 'top' ? 'Add sample at top' : mode.type === 'bottom' ? 'Add sample at bottom' : mode.type === 'above' ? 'Insert sample above' : 'Insert sample below';
      qs('#addSampleForm').reset();
      qs('#addSampleModal').classList.add('visible');
    }

    qs('#addSampleCancel').addEventListener('click', () => {
      qs('#addSampleModal').classList.remove('visible');
      state.addSampleMode = null;
    });

    qs('#addSampleForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const mode = state.addSampleMode;
      if (!mode || !state.group || state.sourceId == null) return;
      const text = (qs('#addText').value || '').trim();
      if (!text) {
        toast('Chunk text is required.');
        return;
      }
      const concept = (qs('#addConcept').value || '').trim();
      const decision_context = (qs('#addDecisionContext').value || '').trim();
      const primary_question_answered = (qs('#addPrimaryQuestion').value || '').trim();
      const key_signalsRaw = (qs('#addKeySignals').value || '').trim();
      const key_signals = key_signalsRaw ? key_signalsRaw.split(/\n/).map(s => s.trim()).filter(Boolean) : [];
      const chunk_role = (qs('#addChunkRole').value || '').trim();
      let body = { text, concept: concept || null, decision_context: decision_context || null, primary_question_answered: primary_question_answered || null, key_signals: key_signals.length ? key_signals : null, chunk_role: chunk_role || null };
      if (mode.type === 'top') body.before_index = 0;
      else if (mode.type === 'bottom') body.after_index = state.chunks.length ? Math.max(...state.chunks.map(c => c.chunk_index)) : undefined;
      else if (mode.type === 'above') body.before_index = mode.index;
      else if (mode.type === 'below') body.after_index = mode.index;
      try {
        const r = await fetch(API + `/groups/${encodeURIComponent(state.group)}/sources/${state.sourceId}/chunks`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
        });
        if (!r.ok) throw new Error();
        qs('#addSampleModal').classList.remove('visible');
        state.addSampleMode = null;
        toast('Added.');
        loadChunks();
      } catch (e) {
        toast('Failed to add.');
      }
    });

    qs('#addAtTop').addEventListener('click', () => openAddSampleModal({ type: 'top' }));
    qs('#addAtBottom').addEventListener('click', () => openAddSampleModal({ type: 'bottom' }));

    loadGroups();
  </script>
</body>
</html>
